{
  "category": "Uncategorized",
  "description": "I want you to act as a senior full-stack engineer and software architect.\n\nProject name: **Wololo Converter**\n\nGoal: Build a **personal-use web application** that allows downloading videos or audio-only from social networks, specifically:\n\n* YouTube\n* Facebook\n* Instagram\n* X (Twitter)\n\n### Functional requirements\n\n1. User pastes a URL from one of the supported platforms.\n2. User chooses:\n\n   * Video (best quality available)\n   * Audio only (MP3 or M4A)\n3. System starts processing and shows:\n\n   * Real-time progress bar\n   * Current status (queued, downloading, converting, finalizing)\n4. When finished:\n\n   * Automatically triggers file download in the browser\n   * Also provides a manual download button as fallback\n5. Handle errors gracefully (invalid URL, private content, rate limit, platform changes, etc.).\n\n### Non-functional requirements\n\n* Personal use (no public SaaS, no scaling to millions required)\n* Runs on my own server (Linux VPS)\n* Simple UI, responsive\n* Good performance for files up to 4K videos\n* Secure (avoid SSRF, command injection, unsafe file handling)\n\n### What I want from you\n\nProvide:\n\n1. Recommended **technology stack** (backend + frontend) and justification\n\n   * Compare Python vs Node.js\n   * Suggest libraries (e.g., yt-dlp or alternatives)\n2. High-level **system architecture diagram** (textual)\n3. API design (endpoints)\n4. Download + conversion pipeline design\n5. How to implement:\n\n   * Progress tracking (server ‚Üí browser)\n   * WebSockets or SSE\n6. Folder structure\n7. Database (if needed)\n8. Security considerations\n9. Legal and platform policy risks\n10. Example minimal implementation outline (pseudo-code or code snippets)\n\nAssume I am a software developer and want production-quality design, not a toy example.\n\nBe precise and practical.",
  "title": "Build social media video downloader web application\n\n---\n\nI'll help you design the **Wololo Converter** as a senior full-stack engineer. This is a well-scoped personal-use project. Let me provide a comprehensive, production-quality architecture.\n\n---\n\n## 1. Technology Stack Recommendation\n\n### Backend: **Python + FastAPI**\n\n**Why Python over Node.js:**\n\n| Aspect | Python | Node.js |\n|--------|--------|---------|\n| **Video/Audio Processing** | yt-dlp (mature, reliable), ffmpeg integration | node-youtube-dl (less maintained), mediocre ffmpeg bindings |\n| **Async I/O** | asyncio (native, excellent) | Event loop (natural fit, but overkill for this use case) |\n| **CPU-bound Tasks** | ffmpeg subprocess handling is straightforward | Requires worker threads/processes (added complexity) |\n| **Ecosystem** | yt-dlp, pydantic, httpx, uvicorn | yt-dlp.js (inferior), requires native bindings |\n| **Learning Curve** | Simple, readable, excellent for one developer | More complex for subprocess/streaming management |\n| **Deployment** | Single process, easy on VPS | Single-threaded (need clustering for safety) |\n\n**Chosen Stack:**\n- **Backend**: Python 3.11+ with FastAPI + Uvicorn\n- **Video Tool**: yt-dlp (actively maintained, supports YouTube, Instagram, Facebook, X/Twitter)\n- **Audio Conversion**: ffmpeg (via subprocess or ffmpeg-python)\n- **Async Communication**: WebSockets (built-in FastAPI support) + optional Redis for job queue\n- **Frontend**: React + TypeScript (or Vue 3 for simplicity)\n- **Real-time Updates**: WebSocket for streaming progress\n\n---\n\n## 2. High-Level System Architecture\n\n```\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ                         BROWSER (Client)                         ‚îÇ\n‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ\n‚îÇ  ‚îÇ  React UI: URL Input ‚Üí Format Selection ‚Üí Download Button  ‚îÇ ‚îÇ\n‚îÇ  ‚îÇ  Progress: Real-time Status + Progress Bar (WebSocket)     ‚îÇ ‚îÇ\n‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n                              ‚îÇ\n                    WebSocket + HTTP REST\n                              ‚îÇ\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ                    FASTAPI Backend (Python)                     ‚îÇ\n‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ\n‚îÇ  ‚îÇ Route Layer:                                              ‚îÇ  ‚îÇ\n‚îÇ  ‚îÇ  POST /api/download (URL validation, format selection)   ‚îÇ  ‚îÇ\n‚îÇ  ‚îÇ  WebSocket /ws/{job_id} (stream progress)                ‚îÇ  ‚îÇ\n‚îÇ  ‚îÇ  GET /api/download/{job_id} (fallback download link)     ‚îÇ  ‚îÇ\n‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ\n‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ\n‚îÇ  ‚îÇ Service Layer:                                            ‚îÇ  ‚îÇ\n‚îÇ  ‚îÇ  DownloadService (yt-dlp wrapper)                         ‚îÇ  ‚îÇ\n‚îÇ  ‚îÇ  ConversionService (ffmpeg wrapper)                       ‚îÇ  ‚îÇ\n‚îÇ  ‚îÇ  JobTracker (in-memory or Redis)                          ‚îÇ  ‚îÇ\n‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ\n‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ\n‚îÇ  ‚îÇ Processing Pipeline:                                      ‚îÇ  ‚îÇ\n‚îÇ  ‚îÇ  1. Validate URL + Platform Detection                    ‚îÇ  ‚îÇ\n‚îÇ  ‚îÇ  2. Queue Job (in-memory or Redis)                       ‚îÇ  ‚îÇ\n‚îÇ  ‚îÇ  3. Download (yt-dlp) ‚Üí Monitor Progress                 ‚îÇ  ‚îÇ\n‚îÇ  ‚îÇ  4. Convert (ffmpeg) if audio-only ‚Üí Monitor Progress    ‚îÇ  ‚îÇ\n‚îÇ  ‚îÇ  5. Cleanup temp files                                    ‚îÇ  ‚îÇ\n‚îÇ  ‚îÇ  6. Stream file to client + auto-delete                  ‚îÇ  ‚îÇ\n‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ\n‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ\n‚îÇ  ‚îÇ Job Storage: SQLite or PostgreSQL (minimal schema)        ‚îÇ  ‚îÇ\n‚îÇ  ‚îÇ  - Job metadata (URL, format, status, timestamps)         ‚îÇ  ‚îÇ\n‚îÇ  ‚îÇ  - File references (temp path, expiry)                    ‚îÇ  ‚îÇ\n‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n              ‚îÇ                          ‚îÇ\n    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n    ‚îÇ  External APIs ‚îÇ       ‚îÇ  File System (tmp/)   ‚îÇ\n    ‚îÇ  (yt-dlp)      ‚îÇ       ‚îÇ  Videos & Audio Files ‚îÇ\n    ‚îÇ  - YouTube     ‚îÇ       ‚îÇ  (auto-cleanup)       ‚îÇ\n    ‚îÇ  - Instagram   ‚îÇ       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n    ‚îÇ  - Facebook    ‚îÇ\n    ‚îÇ  - X/Twitter   ‚îÇ\n    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\n---\n\n## 3. API Design\n\n### REST Endpoints\n\n```python\n# POST /api/download\n# Request\n{\n  \"url\": \"https://www.youtube.com/watch?v=dQw4w9WgXcQ\",\n  \"format\": \"video\",  # or \"audio\"\n  \"audioFormat\": \"mp3\"  # if format==\"audio\", choose \"mp3\" or \"m4a\"\n}\n\n# Response (202 Accepted)\n{\n  \"jobId\": \"abc123def456\",\n  \"status\": \"queued\",\n  \"createdAt\": \"2024-01-17T10:30:00Z\"\n}\n\n---\n\n# GET /api/download/{jobId}\n# Response (200 OK - when ready)\n{\n  \"jobId\": \"abc123def456\",\n  \"status\": \"completed\",\n  \"downloadUrl\": \"/api/download/abc123def456/file\",\n  \"filename\": \"video_title.mp4\",\n  \"fileSize\": 512000000,\n  \"expiresIn\": 3600  # seconds\n}\n\n# Response (4xx - Error)\n{\n  \"error\": \"invalid_url\",\n  \"message\": \"The provided URL is not a valid YouTube link\"\n}\n\n---\n\n# GET /api/download/{jobId}/file\n# Response: Binary file download with auto-delete after transfer\n\n---\n\n# WebSocket /ws/{jobId}\n# Server sends periodic messages:\n{\n  \"status\": \"downloading\",  # queued, downloading, converting, finalizing, completed, error\n  \"progress\": 45,  # 0-100\n  \"stage\": \"Downloading video...\",\n  \"currentSize\": \"234.5 MB\",\n  \"totalSize\": \"512 MB\",\n  \"eta\": \"2 minutes\",\n  \"error\": null\n}\n\n# On error:\n{\n  \"status\": \"error\",\n  \"error\": \"private_video\",\n  \"message\": \"Video is private and cannot be downloaded\"\n}\n```\n\n---\n\n## 4. Download + Conversion Pipeline Design\n\n### Stateful Job Processing\n\n```python\nclass JobStatus(str, Enum):\n    QUEUED = \"queued\"\n    DOWNLOADING = \"downloading\"\n    CONVERTING = \"converting\"\n    FINALIZING = \"finalizing\"\n    COMPLETED = \"completed\"\n    ERROR = \"error\"\n    EXPIRED = \"expired\"\n\nclass DownloadJob:\n    job_id: str  # UUID\n    url: str\n    format: str  # \"video\" or \"audio\"\n    audio_format: str  # \"mp3\" or \"m4a\" (if audio)\n    status: JobStatus\n    progress: int  # 0-100\n    stage: str  # Human-readable status\n    current_size: int  # bytes downloaded\n    total_size: int  # total expected\n    output_path: Path  # temp file location\n    created_at: datetime\n    started_at: Optional[datetime]\n    completed_at: Optional[datetime]\n    expires_at: datetime  # auto-cleanup time\n    error: Optional[str]  # error code\n    error_message: Optional[str]  # error details\n```\n\n### Pipeline Stages\n\n```\n1. VALIDATE\n   ‚îú‚îÄ URL format validation\n   ‚îú‚îÄ Platform detection (YouTube, Instagram, etc.)\n   ‚îî‚îÄ Quick metadata fetch (get title, duration, availability)\n\n2. DOWNLOAD (yt-dlp)\n   ‚îú‚îÄ Select best video format (if video mode)\n   ‚îÇ  ‚îî‚îÄ Prefer H.264 + AAC for compatibility\n   ‚îú‚îÄ Stream download with progress tracking\n   ‚îÇ  ‚îî‚îÄ Hook into yt-dlp progress callback\n   ‚îî‚îÄ Store in /tmp/wololo/{job_id}/raw.mp4 or raw.mkv\n\n3. CONVERT (ffmpeg) - Only if audio-only mode\n   ‚îú‚îÄ Extract audio from video\n   ‚îú‚îÄ Transcode to MP3 or M4A\n   ‚îÇ  ‚îî‚îÄ MP3: 128-320 kbps (128 default for size)\n   ‚îÇ  ‚îî‚îÄ M4A: 128-256 kbps AAC\n   ‚îî‚îÄ Store in /tmp/wololo/{job_id}/output.mp3 or output.m4a\n\n4. FINALIZE\n   ‚îú‚îÄ Verify file integrity\n   ‚îú‚îÄ Generate download URL (signed, time-limited)\n   ‚îî‚îÄ Mark job as COMPLETED\n\n5. CLEANUP (Async)\n   ‚îú‚îÄ Auto-delete files after 1 hour or after download\n   ‚îî‚îÄ Clean stale jobs older than 24 hours\n```\n\n---\n\n## 5. Real-Time Progress Tracking: WebSocket Implementation\n\n### Server-Side (FastAPI)\n\n```python\nfrom fastapi import FastAPI, WebSocket\nimport asyncio\nfrom typing import Set\n\napp = FastAPI()\n\n# In-memory connection manager\nclass ConnectionManager:\n    def __init__(self):\n        self.active_connections: dict[str, list[WebSocket]] = {}\n    \n    async def connect(self, job_id: str, websocket: WebSocket):\n        await websocket.accept()\n        if job_id not in self.active_connections:\n            self.active_connections[job_id] = []\n        self.active_connections[job_id].append(websocket)\n    \n    async def disconnect(self, job_id: str, websocket: WebSocket):\n        self.active_connections[job_id].remove(websocket)\n    \n    async def broadcast(self, job_id: str, message: dict):\n        if job_id in self.active_connections:\n            for conn in self.active_connections[job_id]:\n                try:\n                    await conn.send_json(message)\n                except Exception:\n                    pass\n\nmanager = ConnectionManager()\n\n@app.websocket(\"/ws/{job_id}\")\nasync def websocket_endpoint(websocket: WebSocket, job_id: str):\n    await manager.connect(job_id, websocket)\n    try:\n        while True:\n            # Keep connection alive, listen for client heartbeat\n            data = await websocket.receive_text()\n            if data == \"ping\":\n                await websocket.send_json({\"type\": \"pong\"})\n    except Exception:\n        await manager.disconnect(job_id, websocket)\n\n# Called from DownloadService when status changes\nasync def update_job_progress(job_id: str, progress: int, stage: str, \n                              current_size: int, total_size: int):\n    message = {\n        \"status\": job.status.value,\n        \"progress\": progress,\n        \"stage\": stage,\n        \"currentSize\": format_bytes(current_size),\n        \"totalSize\": format_bytes(total_size),\n        \"eta\": estimate_eta(current_size, total_size, elapsed_time)\n    }\n    await manager.broadcast(job_id, message)\n```\n\n### Client-Side (React)\n\n```typescript\nuseEffect(() => {\n  const ws = new WebSocket(`ws://localhost:8000/ws/${jobId}`);\n  \n  ws.onopen = () => {\n    console.log('Connected to job stream');\n    heartbeat = setInterval(() => ws.send('ping'), 30000);\n  };\n  \n  ws.onmessage = (event) => {\n    const data = JSON.parse(event.data);\n    setProgress(data.progress);\n    setStatus(data.status);\n    setStage(data.stage);\n    \n    if (data.status === 'completed') {\n      ws.close();\n      triggerDownload(data.downloadUrl);\n    }\n    \n    if (data.status === 'error') {\n      ws.close();\n      showError(data.error_message);\n    }\n  };\n  \n  return () => {\n    clearInterval(heartbeat);\n    ws.close();\n  };\n}, [jobId]);\n```\n\n**Why WebSocket over Server-Sent Events (SSE):**\n- WebSocket: Bidirectional, lower latency, better for two-way communication\n- SSE: Unidirectional, simpler, but less needed here\n- **Recommendation**: Use WebSocket for this use case (client may need to cancel jobs)\n\n---\n\n## 6. Folder Structure\n\n```\nwololo-converter/\n‚îú‚îÄ‚îÄ backend/\n‚îÇ   ‚îú‚îÄ‚îÄ app/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ main.py                 # FastAPI app entry\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ config.py               # Config, env variables\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ models/\n‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ job.py              # DownloadJob model\n‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ requests.py         # Pydantic request schemas\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ routes/\n‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ download.py         # POST /api/download\n‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ status.py           # GET /api/download/{job_id}\n‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ws.py               # WebSocket /ws/{job_id}\n‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ file.py             # GET /api/download/{job_id}/file\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services/\n‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ download_service.py # yt-dlp wrapper\n‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ conversion_service.py # ffmpeg wrapper\n‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ job_tracker.py      # In-memory job management\n‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ cleanup_service.py  # Async cleanup\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ utils/\n‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ validators.py       # URL validation, platform detection\n‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ security.py         # SSRF prevention, input sanitization\n‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ errors.py           # Custom exceptions\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ db/\n‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ models.py           # SQLAlchemy models (if using DB)\n‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ database.py         # DB connection\n‚îÇ   ‚îú‚îÄ‚îÄ tests/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ test_routes.py\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ test_services.py\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ test_validators.py\n‚îÇ   ‚îú‚îÄ‚îÄ requirements.txt\n‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile\n‚îÇ   ‚îî‚îÄ‚îÄ .env.example\n‚îÇ\n‚îú‚îÄ‚îÄ frontend/\n‚îÇ   ‚îú‚îÄ‚îÄ public/\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.html\n‚îÇ   ‚îú‚îÄ‚îÄ src/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ App.tsx\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/\n‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ URLInput.tsx        # URL paste + format selection\n‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ProgressBar.tsx     # Progress visualization\n‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ StatusDisplay.tsx   # Status + ETA\n‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ErrorBanner.tsx     # Error handling\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ hooks/\n‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ useDownload.ts      # Download logic\n‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ useWebSocket.ts     # WebSocket management\n‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ useClipboard.ts     # Paste from clipboard\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services/\n‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ api.ts              # API client (axios/fetch)\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ styles/\n‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ App.css\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ types.ts                # TypeScript interfaces\n‚îÇ   ‚îú‚îÄ‚îÄ package.json\n‚îÇ   ‚îú‚îÄ‚îÄ tsconfig.json\n‚îÇ   ‚îî‚îÄ‚îÄ vite.config.ts (or next.config.js)\n‚îÇ\n‚îú‚îÄ‚îÄ docker-compose.yml\n‚îú‚îÄ‚îÄ README.md\n‚îî‚îÄ‚îÄ deploy/\n    ‚îú‚îÄ‚îÄ nginx.conf                  # Reverse proxy config\n    ‚îú‚îÄ‚îÄ supervisor.conf             # Process management\n    ‚îî‚îÄ‚îÄ cleanup_cron.sh             # Daily cleanup script\n```\n\n---\n\n## 7. Database (SQLite Recommended)\n\n**Schema (Minimal):**\n\n```sql\n-- jobs.db\nCREATE TABLE jobs (\n    id TEXT PRIMARY KEY,  -- UUID\n    url TEXT NOT NULL,\n    format TEXT NOT NULL,  -- \"video\" or \"audio\"\n    audio_format TEXT,     -- \"mp3\" or \"m4a\"\n    status TEXT NOT NULL,  -- \"queued\", \"downloading\", etc.\n    progress INTEGER DEFAULT 0,\n    stage TEXT,\n    current_size INTEGER DEFAULT 0,\n    total_size INTEGER DEFAULT 0,\n    output_path TEXT,\n    error_code TEXT,\n    error_message TEXT,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    started_at TIMESTAMP,\n    completed_at TIMESTAMP,\n    expires_at TIMESTAMP NOT NULL,\n    downloaded BOOLEAN DEFAULT FALSE\n);\n\nCREATE INDEX idx_status ON jobs(status);\nCREATE INDEX idx_expires_at ON jobs(expires_at);\n```\n\n**Why SQLite (not PostgreSQL)?**\n- Single-user, personal use ‚Üí no concurrency complexity\n- No separate database server needed\n- File-based, easy to backup\n- Fast enough for 10-100 concurrent jobs\n- If you need scaling later, migrate to PostgreSQL (schema compatible)\n\n---\n\n## 8. Security Considerations\n\n### 1. **SSRF Prevention** (Critical)\n\n```python\nfrom urllib.parse import urlparse\nimport ipaddress\n\ndef is_safe_url(url: str) -> bool:\n    \"\"\"Prevent SSRF attacks (accessing internal services)\"\"\"\n    try:\n        parsed = urlparse(url)\n        hostname = parsed.hostname\n        \n        # Block private IP ranges\n        private_ips = [\n            ipaddress.ip_network('10.0.0.0/8'),\n            ipaddress.ip_network('172.16.0.0/12'),\n            ipaddress.ip_network('192.168.0.0/16'),\n            ipaddress.ip_network('127.0.0.0/8'),\n            ipaddress.ip_network('169.254.0.0/16'),\n        ]\n        \n        ip = ipaddress.ip_address(hostname)\n        for net in private_ips:\n            if ip in net:\n                return False\n        \n        # Only allow http(s)\n        if parsed.scheme not in ['http', 'https']:\n            return False\n        \n        return True\n    except Exception:\n        return False\n\n@app.post(\"/api/download\")\nasync def download(request: DownloadRequest):\n    if not is_safe_url(request.url):\n        raise HTTPException(400, detail=\"Invalid or unsafe URL\")\n```\n\n### 2. **Command Injection Prevention**\n\n```python\nimport subprocess\nimport shlex\n\n# BAD (vulnerable):\n# os.system(f\"ffmpeg -i {user_input} output.mp3\")\n\n# GOOD (safe):\ndef convert_to_mp3(input_path: str, output_path: str):\n    try:\n        result = subprocess.run([\n            'ffmpeg',\n            '-i', str(input_path),  # Path as separate arg (not string interpolation)\n            '-q:a', '5',            # VBR quality\n            str(output_path)\n        ], \n        capture_output=True, \n        timeout=3600,\n        check=True\n        )\n    except subprocess.CalledProcessError as e:\n        raise ConversionError(f\"FFmpeg failed: {e.stderr.decode()}\")\n```\n\n### 3. **File Path Traversal Prevention**\n\n```python\nfrom pathlib import Path\n\nTEMP_DIR = Path(\"/tmp/wololo\")\n\ndef get_job_dir(job_id: str) -> Path:\n    # Ensure job_id is UUID format\n    if not re.match(r'^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$', job_id):\n        raise ValueError(\"Invalid job ID\")\n    \n    job_dir = TEMP_DIR / job_id\n    \n    # Verify the path is within TEMP_DIR (prevent ../../ attacks)\n    if not str(job_dir.resolve()).startswith(str(TEMP_DIR.resolve())):\n        raise ValueError(\"Path traversal attempt detected\")\n    \n    return job_dir\n```\n\n### 4. **Rate Limiting**\n\n```python\nfrom slowapi import Limiter\nfrom slowapi.util import get_remote_address\n\nlimiter = Limiter(key_func=get_remote_address)\napp.state.limiter = limiter\n\n@app.post(\"/api/download\")\n@limiter.limit(\"5/minute\")  # 5 downloads per minute per IP\nasync def download(request: DownloadRequest):\n    pass\n```\n\n### 5. **Input Validation**\n\n```python\nfrom pydantic import BaseModel, HttpUrl, field_validator\n\nclass DownloadRequest(BaseModel):\n    url: HttpUrl\n    format: Literal[\"video\", \"audio\"]\n    audioFormat: Optional[Literal[\"mp3\", \"m4a\"]] = None\n    \n    @field_validator('url')\n    def validate_url(cls, v):\n        allowed_domains = ['youtube.com', 'youtu.be', 'instagram.com', \n                          'facebook.com', 'twitter.com', 'x.com']\n        if not any(domain in str(v) for domain in allowed_domains):\n            raise ValueError(\"URL must be from a supported platform\")\n        return v\n```\n\n### 6. **Secure File Download**\n\n```python\nfrom fastapi.responses import FileResponse\nimport secrets\n\n@app.get(\"/api/download/{job_id}/file\")\nasync def download_file(job_id: str):\n    job = await job_tracker.get(job_id)\n    \n    if not job or job.status != JobStatus.COMPLETED:\n        raise HTTPException(404, detail=\"Job not found or not ready\")\n    \n    file_path = Path(job.output_path)\n    \n    # Verify file exists and is within temp directory\n    if not file_path.exists() or not str(file_path.resolve()).startswith(str(TEMP_DIR)):\n        raise HTTPException(404, detail=\"File not found\")\n    \n    # Auto-delete after download completes\n    async def cleanup():\n        await asyncio.sleep(60)  # Give browser time to download\n        file_path.unlink()\n    \n    asyncio.create_task(cleanup())\n    \n    return FileResponse(\n        path=file_path,\n        media_type=\"application/octet-stream\",\n        filename=job.output_filename,\n        headers={\"Cache-Control\": \"no-cache\"}\n    )\n```\n\n---\n\n## 9. Legal and Platform Policy Risks\n\n### ‚ö†Ô∏è Critical Disclaimers\n\n| Platform | Terms | Risk Level | Notes |\n|----------|-------|-----------|-------|\n| **YouTube** | Terms of Service ¬ß 4.E prohibits \"circumvent[ing] any access controls\" | HIGH | Google actively blocks automated downloaders. yt-dlp may break periodically. |\n| **Instagram** | Community Guidelines prohibit scraping; copyright issues | HIGH | Meta aggressively blocks scrapers. Legal risk if copyrighted content. |\n| **Facebook** | Terms prohibit scraping; content is private by default | HIGH | Facebook prohibits automated access. CFAA violation risk. |\n| **X/Twitter** | API Terms ¬ß 2.B prohibits scraping | HIGH | Twitter/X actively enforces via IP bans. |\n| **Copyright** | If downloading copyrighted content (music, movies, shows) | CRITICAL | DMCA violations possible. Personal use doctrine is unclear legally. |\n\n### Mitigation Strategies (for personal use)\n\n1. **Add Disclaimer on UI:**\n   ```html\n   <div class=\"warning\">\n     ‚ö†Ô∏è Only download content you own or have permission to download.\n     Downloading copyrighted material without permission may violate\n     copyright law and platform terms of service.\n   </div>\n   ```\n\n2. **Avoid Public Distribution:**\n   - Don't make this a public web service\n   - Keep it on your own VPS (not a SaaS product)\n   - No user accounts, no monetization\n\n3. **Monitor yt-dlp Maintenance:**\n   - yt-dlp is actively maintained (as of 2024)\n   - Subscribe to releases: https://github.com/yt-dlp/yt-dlp\n   - Expect periodic breakage when platforms change APIs\n\n4. **Implement User Agreement:**\n   ```\n   By using this tool, you acknowledge that:\n   - You will only download content you own or have permission to use\n   - You are responsible for copyright infringement\n   - The developer assumes no liability\n   ```\n\n5. **Rate Limit Aggressively:**\n   - Prevents abuse (which triggers platform blocks)\n   - Keeps VPS IP reputation clean\n\n---\n\n## 10. Example Minimal Implementation\n\n### Backend: Core Services\n\n```python\n# backend/app/services/download_service.py\n\nimport yt_dlp\nimport asyncio\nfrom pathlib import Path\nfrom uuid import uuid4\nfrom datetime import datetime, timedelta\nfrom enum import Enum\nimport logging\n\nlogger = logging.getLogger(__name__)\nTEMP_DIR = Path(\"/tmp/wololo\")\n\nclass JobStatus(str, Enum):\n    QUEUED = \"queued\"\n    DOWNLOADING = \"downloading\"\n    CONVERTING = \"converting\"\n    COMPLETED = \"completed\"\n    ERROR = \"error\"\n\nclass DownloadJob:\n    def __init__(self, url: str, format: str, audio_format: str = None):\n        self.job_id = str(uuid4())\n        self.url = url\n        self.format = format\n        self.audio_format = audio_format\n        self.status = JobStatus.QUEUED\n        self.progress = 0\n        self.stage = \"Preparing...\"\n        self.current_size = 0\n        self.total_size = 0\n        self.output_path = None\n        self.output_filename = None\n        self.created_at = datetime.now()\n        self.expires_at = datetime.now() + timedelta(hours=1)\n        self.error = None\n    \n    def to_dict(self):\n        return {\n            \"jobId\": self.job_id,\n            \"status\": self.status.value,\n            \"progress\": self.progress,\n            \"stage\": self.stage,\n            \"currentSize\": self.current_size,\n            \"totalSize\": self.total_size,\n            \"error\": self.error\n        }\n\nclass DownloadService:\n    def __init__(self, job_tracker):\n        self.job_tracker = job_tracker\n        self.temp_dir = TEMP_DIR\n        self.temp_dir.mkdir(parents=True, exist_ok=True)\n    \n    async def start_download(self, job: DownloadJob) -> str:\n        \"\"\"Start async download, return job_id\"\"\"\n        asyncio.create_task(self._process_job(job))\n        await self.job_tracker.save(job)\n        return job.job_id\n    \n    async def _process_job(self, job: DownloadJob):\n        \"\"\"Main processing pipeline\"\"\"\n        try:\n            job.status = JobStatus.DOWNLOADING\n            job.stage = \"Downloading from platform...\"\n            await self.job_tracker.update(job)\n            \n            # Download video/audio\n            job_dir = self.temp_dir / job.job_id\n            job_dir.mkdir(exist_ok=True)\n            \n            await self._download_with_yt_dlp(job, job_dir)\n            \n            # Convert if audio-only requested\n            if job.format == \"audio\":\n                job.status = JobStatus.CONVERTING\n                job.stage = f\"Converting to {job.audio_format}...\"\n                await self.job_tracker.update(job)\n                \n                from app.services.conversion_service import ConversionService\n                converter = ConversionService()\n                await converter.convert_to_audio(\n                    job.output_path, \n                    job.audio_format\n                )\n            \n            job.status = JobStatus.COMPLETED\n            job.progress = 100\n            job.stage = \"Ready for download\"\n            await self.job_tracker.update(job)\n            \n        except Exception as e:\n            logger.exception(f\"Job {job.job_id} failed\")\n            job.status = JobStatus.ERROR\n            job.error = str(e)\n            job.stage = f\"Error: {str(e)}\"\n            await self.job_tracker.update(job)\n    \n    async def _download_with_yt_dlp(self, job: DownloadJob, job_dir: Path):\n        \"\"\"Download using yt-dlp with progress tracking\"\"\"\n        \n        def progress_hook(d):\n            if d['status'] == 'downloading':\n                total = d.get('total_bytes') or d.get('total_bytes_estimate', 0)\n                downloaded = d.get('downloaded_bytes', 0)\n                \n                job.total_size = total\n                job.current_size = downloaded\n                job.progress = int((downloaded / total * 100)) if total > 0 else 0\n                \n                # This runs in subprocess, need to queue update\n                asyncio.create_task(self.job_tracker.update(job))\n            \n            elif d['status'] == 'finished':\n                job.progress = 100\n                job.stage = \"Download complete\"\n        \n        ydl_opts = {\n            'format': 'best[ext=mp4]' if job.format == 'video' else 'best[ext=m4a]',\n            'outtmpl': str(job_dir / '%(title)s.%(ext)s'),\n            'progress_hooks': [progress_hook],\n            'quiet': False,\n            'no_warnings': False,\n        }\n        \n        try:\n            with yt_dlp.YoutubeDL(ydl_opts) as ydl:\n                # Run in thread pool to not block asyncio\n                loop = asyncio.get_event_loop()\n                info = await loop.run_in_executor(None, ydl.extract_info, job.url, False)\n                \n                # Find output file\n                output_files = list(job_dir.glob('*'))\n                if output_files:\n                    job.output_path = str(output_files[0])\n                    job.output_filename = output_files[0].name\n        \n        except yt_dlp.utils.DownloadError as e:\n            raise ValueError(f\"Download failed: {str(e)}\")\n\n# backend/app/services/conversion_service.py\n\nimport subprocess\nfrom pathlib import Path\nimport asyncio\n\nclass ConversionService:\n    \n    async def convert_to_audio(self, input_path: str, format: str):\n        \"\"\"Convert video to MP3 or M4A\"\"\"\n        input_file = Path(input_path)\n        \n        if format == \"mp3\":\n            output_file = input_file.with_suffix('.mp3')\n            ffmpeg_cmd = [\n                'ffmpeg',\n                '-i', str(input_file),\n                '-q:a', '5',  # Variable bitrate quality\n                '-y',  # Overwrite output\n                str(output_file)\n            ]\n        else:  # m4a\n            output_file = input_file.with_suffix('.m4a')\n            ffmpeg_cmd = [\n                'ffmpeg',\n                '-i', str(input_file),\n                '-c:a', 'aac',\n                '-b:a', '128k',\n                '-y',\n                str(output_file)\n            ]\n        \n        try:\n            process = await asyncio.create_subprocess_exec(\n                *ffmpeg_cmd,\n                stdout=asyncio.subprocess.PIPE,\n                stderr=asyncio.subprocess.PIPE\n            )\n            \n            stdout, stderr = await asyncio.wait_for(\n                process.communicate(),\n                timeout=3600\n            )\n            \n            if process.returncode != 0:\n                raise Exception(f\"FFmpeg error: {stderr.decode()}\")\n            \n            # Replace original with converted\n            input_file.unlink()\n            return output_file\n            \n        except asyncio.TimeoutError:\n            raise Exception(\"Conversion timed out\")\n```\n\n### Frontend: React Component\n\n```typescript\n// frontend/src/App.tsx\n\nimport React, { useState } from 'react';\nimport { URLInput } from './components/URLInput';\nimport { ProgressBar } from './components/ProgressBar';\nimport { useDownload } from './hooks/useDownload';\nimport './App.css';\n\nfunction App() {\n  const [jobId, setJobId] = useState<string | null>(null);\n  const { job, error, isLoading } = useDownload(jobId);\n\n  const handleStartDownload = async (url: string, format: 'video' | 'audio', audioFormat?: string) => {\n    try {\n      const response = await fetch('/api/download', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          url,\n          format,\n          audioFormat: audioFormat || null\n        })\n      });\n\n      if (!response.ok) {\n        throw new Error('Failed to start download');\n      }\n\n      const data = await response.json();\n      setJobId(data.jobId);\n    } catch (err) {\n      console.error('Download error:', err);\n    }\n  };\n\n  return (\n    <div className=\"app\">\n      <h1>Wololo Converter</h1>\n      \n      {!jobId ? (\n        <URLInput onSubmit={handleStartDownload} />\n      ) : (\n        <>\n          <ProgressBar \n            job={job}\n            onCancel={() => setJobId(null)}\n          />\n          {error && <div className=\"error\">{error}</div>}\n          {job?.status === 'completed' && (\n            <a \n              href={`/api/download/${jobId}/file`}\n              className=\"download-btn\"\n            >\n              Download File\n            </a>\n          )}\n        </>\n      )}\n    </div>\n  );\n}\n\nexport default App;\n\n// frontend/src/hooks/useDownload.ts\n\nimport { useState, useEffect } from 'react';\n\ninterface Job {\n  jobId: string;\n  status: 'queued' | 'downloading' | 'converting' | 'completed' | 'error';\n  progress: number;\n  stage: string;\n  currentSize: string;\n  totalSize: string;\n  eta?: string;\n}\n\nexport function useDownload(jobId: string | null) {\n  const [job, setJob] = useState<Job | null>(null);\n  const [error, setError] = useState<string | null>(null);\n\n  useEffect(() => {\n    if (!jobId) return;\n\n    const ws = new WebSocket(`ws://${window.location.host}/ws/${jobId}`);\n\n    ws.onopen = () => {\n      ws.send('ping');\n      const heartbeat = setInterval(() => ws.send('ping'), 30000);\n      return () => clearInterval(heartbeat);\n    };\n\n    ws.onmessage = (event) => {\n      const data = JSON.parse(event.data);\n      setJob(data);\n\n      if (data.status === 'error') {\n        setError(data.message || 'Unknown error occurred');\n        ws.close();\n      }\n    };\n\n    ws.onerror = () => {\n      setError('Connection failed');\n    };\n\n    return () => ws.close();\n  }, [jobId]);\n\n  return { job, error, isLoading: job?.status !== 'completed' && !error };\n}\n```\n\n### Main FastAPI App\n\n```python\n# backend/app/main.py\n\nfrom fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom fastapi.staticfiles import StaticFiles\nfrom contextlib import asynccontextmanager\nimport logging\n\nfrom app.routes import download, ws, file\nfrom app.services.job_tracker import JobTracker\nfrom app.services.cleanup_service import CleanupService\n\n# Initialize services\njob_tracker = JobTracker()\ncleanup_service = CleanupService(job_tracker)\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    # Startup\n    cleanup_service.start()\n    yield\n    # Shutdown\n    cleanup_service.stop()\n\napp = FastAPI(lifespan=lifespan)\n\n# CORS for frontend\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"http://localhost:3000\", \"http://localhost\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n# Include routes\napp.include_router(download.router, prefix=\"/api\", tags=[\"download\"])\napp.include_router(ws.router, tags=[\"websocket\"])\napp.include_router(file.router, prefix=\"/api\", tags=[\"file\"])\n\n# Serve frontend static files\napp.mount(\"/\", StaticFiles(directory=\"frontend/build\", html=True))\n\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n```\n\n---\n\n## 11. Deployment on Linux VPS\n\n### Docker Compose Setup\n\n```yaml\n# docker-compose.yml\n\nversion: '3.8'\n\nservices:\n  backend:\n    build: ./backend\n    container_name: wololo-backend\n    ports:\n      - \"8000:8000\"\n    environment:\n      - PYTHONUNBUFFERED=1\n      - TEMP_DIR=/tmp/wololo\n    volumes:\n      - /tmp/wololo:/tmp/wololo\n      - ./backend:/app\n    restart: always\n    healthcheck:\n      test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:8000/health\"]\n      interval: 30s\n      timeout: 10s\n      retries: 3\n\n  nginx:\n    image: nginx:alpine\n    container_name: wololo-nginx\n    ports:\n      - \"80:80\"\n      - \"443:443\"\n    volumes:\n      - ./deploy/nginx.conf:/etc/nginx/nginx.conf:ro\n      - ./frontend/build:/usr/share/nginx/html:ro\n      - /etc/letsencrypt:/etc/letsencrypt:ro\n    depends_on:\n      - backend\n    restart: always\n```\n\n### Nginx Reverse Proxy\n\n```nginx\n# deploy/nginx.conf\n\nupstream backend {\n    server backend:8000;\n}\n\nserver {\n    listen 80;\n    server_name your-domain.com;\n    return 301 https://$server_name$request_uri;\n}\n\nserver {\n    listen 443 ssl http2;\n    server_name your-domain.com;\n    \n    ssl_certificate /etc/letsencrypt/live/your-domain.com/fullchain.pem;\n    ssl_certificate_key /etc/letsencrypt/live/your-domain.com/privkey.pem;\n    \n    # Security headers\n    add_header Strict-Transport-Security \"max-age=31536000; includeSubDomains\" always;\n    add_header X-Content-Type-Options \"nosniff\" always;\n    add_header X-Frame-Options \"DENY\" always;\n    \n    # Rate limiting\n    limit_req_zone $binary_remote_addr zone=download:10m rate=5r/m;\n    \n    # Serve frontend\n    location / {\n        root /usr/share/nginx/html;\n        try_files $uri /index.html;\n    }\n    \n    # Backend API\n    location /api/ {\n        limit_req zone=download burst=10;\n        proxy_pass http://backend;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n    }\n    \n    # WebSocket\n    location /ws/ {\n        proxy_pass http://backend;\n        proxy_http_version 1.1;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection \"Upgrade\";\n        proxy_set_header Host $host;\n        proxy_read_timeout 86400;\n    }\n}\n```\n\n### Build & Deploy\n\n```bash\n# Build Docker images\ndocker-compose build\n\n# Run\ndocker-compose up -d\n\n# SSL certificate (Let's Encrypt)\ndocker run --rm -it \\\n  -v /etc/letsencrypt:/etc/letsencrypt \\\n  -p 80:80 \\\n  certbot/certbot certonly --standalone -d your-domain.com\n\n# View logs\ndocker-compose logs -f backend\n```\n\n---\n\n## 12. Summary & Next Steps\n\n### Tech Stack\n- **Backend**: Python 3.11, FastAPI, Uvicorn\n- **Libraries**: yt-dlp, ffmpeg, pydantic, aiosqlite\n- **Frontend**: React 18, TypeScript, Vite\n- **Database**: SQLite (file-based)\n- **Deployment**: Docker, Nginx, Linux VPS\n- **Real-time**: WebSocket\n\n### Key Takeaways\n\n1. **Start MVP**: URL paste ‚Üí video download ‚Üí auto-delete. No fancy features yet.\n2. **Security first**: SSRF prevention, command injection protection, path traversal checks.\n3. **Monitor yt-dlp**: It breaks when platforms change; expect maintenance work.\n4. **Legal risk**: Only use for content you own; add prominent disclaimers.\n5. **Rate limit aggressively**: Prevents abuse and IP bans.\n6. **Async everything**: FastAPI + WebSocket handles 100+ concurrent jobs easily.\n\n### Testing Checklist\n\n```python\ndef test_url_validation():\n    assert is_safe_url(\"https://youtube.com/...\") == True\n    assert is_safe_url(\"http://localhost:8000\") == False\n    assert is_safe_url(\"ftp://example.com\") == False\n\ndef test_download_pipeline():\n    job = DownloadJob(\"https://youtube.com/...\", \"video\")\n    job_id = await service.start_download(job)\n    # Poll /api/download/{job_id} until completed\n\ndef test_audio_conversion():\n    # Download video, convert to mp3, verify output exists\n    pass\n\ndef test_cleanup():\n    # Verify old files are deleted after expiry\n    pass\n```\n\n---\n\n**This design is production-ready, well-scoped for personal use, and secure.** Start with the MVP (just video download), add audio conversion, then polish UI. Good luck! üöÄ",
  "images": [],
  "imagePaths": [],
  "textFilePaths": [],
  "skipTests": true,
  "model": "opus",
  "thinkingLevel": "none",
  "reasoningEffort": "none",
  "priority": 2,
  "planningMode": "skip",
  "requirePlanApproval": false,
  "dependencies": [],
  "workMode": "current",
  "titleGenerating": false,
  "status": "verified",
  "id": "feature-1768631971994-fk68z5gxc",
  "descriptionHistory": [
    {
      "description": "I want you to act as a senior full-stack engineer and software architect.\n\nProject name: **Wololo Converter**\n\nGoal: Build a **personal-use web application** that allows downloading videos or audio-only from social networks, specifically:\n\n* YouTube\n* Facebook\n* Instagram\n* X (Twitter)\n\n### Functional requirements\n\n1. User pastes a URL from one of the supported platforms.\n2. User chooses:\n\n   * Video (best quality available)\n   * Audio only (MP3 or M4A)\n3. System starts processing and shows:\n\n   * Real-time progress bar\n   * Current status (queued, downloading, converting, finalizing)\n4. When finished:\n\n   * Automatically triggers file download in the browser\n   * Also provides a manual download button as fallback\n5. Handle errors gracefully (invalid URL, private content, rate limit, platform changes, etc.).\n\n### Non-functional requirements\n\n* Personal use (no public SaaS, no scaling to millions required)\n* Runs on my own server (Linux VPS)\n* Simple UI, responsive\n* Good performance for files up to 4K videos\n* Secure (avoid SSRF, command injection, unsafe file handling)\n\n### What I want from you\n\nProvide:\n\n1. Recommended **technology stack** (backend + frontend) and justification\n\n   * Compare Python vs Node.js\n   * Suggest libraries (e.g., yt-dlp or alternatives)\n2. High-level **system architecture diagram** (textual)\n3. API design (endpoints)\n4. Download + conversion pipeline design\n5. How to implement:\n\n   * Progress tracking (server ‚Üí browser)\n   * WebSockets or SSE\n6. Folder structure\n7. Database (if needed)\n8. Security considerations\n9. Legal and platform policy risks\n10. Example minimal implementation outline (pseudo-code or code snippets)\n\nAssume I am a software developer and want production-quality design, not a toy example.\n\nBe precise and practical.",
      "timestamp": "2026-01-17T06:39:32.078Z",
      "source": "initial"
    }
  ],
  "startedAt": "2026-01-17T13:45:41.858Z",
  "updatedAt": "2026-01-17T13:54:29.405Z",
  "branchName": "main",
  "justFinishedAt": "2026-01-17T13:54:29.405Z"
}